/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.alechenninger.memorize;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

import java.util.LinkedHashSet;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class InMemoryRepository<E, I> {
  private final ConcurrentHashMap<I, ObjectNode> db;

  private final Set<Consumer<Change>> listeners;
  private final ObjectMapper mapper;

  private final Function<E, I> idOfE;
  private final Class<E> type;
  private final ExecutorService executor = Executors.newSingleThreadExecutor();

  public InMemoryRepository(ObjectMapper mapper, Function<E, I> idOfE, Class<E> type) {
    this(new ConcurrentHashMap<>(), new LinkedHashSet<>(), mapper, idOfE, type);
  }

  public InMemoryRepository(Function<E, I> idOfE, Class<E> type) {
    this(defaultObjectMapper(), idOfE, type);
  }

  private InMemoryRepository(
      ConcurrentHashMap<I, ObjectNode> db,
      Set<Consumer<Change>> listeners,
      ObjectMapper mapper,
      Function<E, I> idOfE,
      Class<E> type) {
    this.db = Objects.requireNonNull(db, "db");
    this.listeners = Objects.requireNonNull(listeners, "listeners");
    this.mapper = Objects.requireNonNull(mapper, "mapper");
    this.idOfE = Objects.requireNonNull(idOfE, "idOfE");
    this.type = Objects.requireNonNull(type, "type");
  }

  public static Stream<JsonNode> stream(JsonNode node) {
    return StreamSupport.stream(
        Spliterators.spliterator(
            node.iterator(),
            node.size(),
            Spliterator.NONNULL | Spliterator.ORDERED),
        false);
  }

  private static ObjectMapper defaultObjectMapper() {
    return new ObjectMapper()
        .registerModule(new JavaTimeModule())
        .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
        .setDefaultVisibility(JsonAutoDetect.Value.construct(
            /*    field*/ JsonAutoDetect.Visibility.ANY,
            /*  getters*/ JsonAutoDetect.Visibility.NONE,
            /*isGetters*/ JsonAutoDetect.Visibility.NONE,
            /*  setters*/ JsonAutoDetect.Visibility.NONE,
            /* creators*/ JsonAutoDetect.Visibility.NONE));
  }

  public synchronized void save(E aggregate) {
    Objects.requireNonNull(aggregate, "aggregate");
    final var id = idOfE.apply(aggregate);
    final var object = mapper.convertValue(aggregate, ObjectNode.class);
    final var before = db.put(id, object);

    if (!listeners.isEmpty()) {
      executor.submit(() -> listeners.forEach(l -> l.accept(new Change(before, object))));
    }
  }

  public E byId(I id) {
    Objects.requireNonNull(id, "id");
    final ObjectNode object = db.get(id);
    if (object == null) throw new NoSuchElementException("No object with id: " + id);
    return mapper.convertValue(object, type);
  }

  public Stream<E> byPredicate(Predicate<ObjectNode> filter) {
    Objects.requireNonNull(filter, "filter");

    return db.values().stream()
        .filter(filter)
        .map(o -> mapper.convertValue(o, type));
  }

  public Stream<E> all() {
    return db.values().stream().map(o -> mapper.convertValue(o, type));
  }

  public long size() {
    return db.values().size();
  }

  public boolean isEmpty() {
    return db.isEmpty();
  }

  public void onChange(Consumer<Change> listener) {
    listeners.add(new ExceptionHandlingConsumer<>(listener));
  }

  private static class ExceptionHandlingConsumer<T> implements Consumer<T> {
    private final Consumer<T> delegate;

    ExceptionHandlingConsumer(Consumer<T> delegate) {
      this.delegate = delegate;
    }

    @Override
    public void accept(T t) {
      try {
        delegate.accept(t);
      } catch (Exception e) {
        // TODO: log
      }
    }
  }

  public class Change {
    private final JsonNode before;
    private final JsonNode after;

    public Change(JsonNode before, JsonNode after) {
      this.before = before;
      this.after = Objects.requireNonNull(after, "after");
    }

    public Optional<JsonNode> jsonBefore() {
      return Optional.ofNullable(before);
    }

    public JsonNode jsonAfter() {
      return after;
    }

    public Optional<E> before() {
      return jsonBefore().map(b -> mapper.convertValue(b, type));
    }

    public E after() {
      return mapper.convertValue(after, type);
    }
  }
}
